#include <math.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>

#define PI M_PI
#define RAD  PI/180.0
#define SIG5 5.0*sig
#define SIG10 10.0*sig
#define SIG20 20.0*sig

float randomgauss(float mean, float sig);
double random_gaussexp(float gauss_sig);
double random_beck_gaensler();
unsigned long long int rdtsc();
int main(int argc, char *argv[])
{
	srandom(rdtsc());
	//sigma is part of the fit parameters (along with A, AA, AB) for the 
	//gaussian+exponential noise distribution
	float sigma = 0.3881;
	float input_p0;
	float sigma_QU;
	float p0;
	char flag;
	int read;
	float discard;
	int idiscard;
	char name[17];
	float theta;
	float Q0;
	float U0;
	float Q;
	float U;
	float PolInt;
	float rnum;
	if (argc>=2)
	{
		input_p0=atof(argv[2]);
	}
	else
	{
		input_p0=0.0;
	}
	FILE * noisefile = fopen(argv[1], "r");
	while(!feof(noisefile))
	{
		read = fscanf(noisefile, "%f %f %E %E %E %d %d %E %d %d %E %E %s %s\n", &discard, &discard, &discard, &discard, &discard, &idiscard, &idiscard, &discard, &idiscard, &idiscard, &sigma_QU, &discard, &flag, name);
		if(flag == 'a' && read == 14)
		{
			rnum = (float) random()/(float) RAND_MAX;
			//6% of sources seeded are unpolarized, as per private 
			//correspondence with Brian Gaensler, and in order to ensure 
			//quartile fit
			if (rnum < 0.06)
			{
				p0=0;
			}
			else
			{
				//The 1.90 factor is generated by taking the median 1 million
				//random draws from the Beck & Gaensler Distribution, while
				//keeping 6% of the draws 0 (to account for unpolarized sources)
				//This normalizes the distribution
				p0=input_p0*random_beck_gaensler()/1.90;
			}
			theta=PI* (float) random()/ (float) RAND_MAX;
			Q0=p0*sin(2.0*theta);
			U0=p0*cos(2.0*theta);
			//0.276786 is the median of the gaussexp_noise expression when 
			//P0 = 0.00
			Q=(Q0+(sigma_QU/0.276786)*random_gaussexp(sigma));
			U=(U0+(sigma_QU/0.276786)*random_gaussexp(sigma));
			PolInt=sqrt(pow(Q, 2)+pow(U, 2));
			printf(" %15.10f  %15.10f  %15.10f  %15.10f \n", p0, PolInt, Q, U);
		}
	}
	fclose(noisefile);
	return 0;
}

float randomgauss(float mean, float sig)
{
	float rA = -0.5 / pow(sig, 2.0);
	float sqrtsig = 1.0 / sig * sqrt(2*PI);
	float rxx=0;
	float ryy=0;
	float rxx2=1.E30;
	while (rxx2>1.E29)
	{
		rxx=((float) random()/(float) RAND_MAX*SIG10)-SIG5;
		ryy=(float) random()/(float) RAND_MAX;
		if (ryy<=(exp(rA*pow(rxx, 2))))
		{
			rxx2 = rxx+mean;
		}
	}
	return rxx2;
}
//This is the Q/U noise distribution function
double random_gaussexp(float gauss_sig)
{
	double norm = 1.0;
	double AA = 1.80;
	double AB = 0.9;
	double A = AB*norm;
	double B = (1.0-AB)*norm;
	double xx=0;
	double xx1;
	double xxsq;
	double FFF;
	double yy=0;
	double xx2=1.E30;
	// Cut off at 12 sigma level.
	// Set cut-off level as small as possible to increase speed.
	double max_xx_pol=12*gauss_sig;
	if (max_xx_pol>100) { max_xx_pol=100;}

	while(xx2>1.E29)
	{
		xx=(2.0*max_xx_pol*(double) random() / (double) RAND_MAX)-max_xx_pol;
		yy=(double) random()/ (double) RAND_MAX;
		xx1=xx;
		xx=xx/gauss_sig;
		xxsq=pow(xx,2);
		FFF=(A/(sqrt(2*PI)*gauss_sig))*exp(-0.5*xxsq)+B*exp(-1.*AA*fabs(xx1));
		if (yy <=FFF)
		{
			xx2=xx*gauss_sig;
		}
	}
	return xx2;

}

//This is the polarized source distribution
double random_beck_gaensler()
{
	double xx=0;
	double yy=0;
	double xx2=1.E30;
	double width=0;
	double amp=0;
	double lxx=0;
	double FFF=0;

	double bg_centre=-1.5;
	while (xx2>1.E29)
	{
		xx=0.70*(double) random()/ (double) RAND_MAX;

		lxx=log10(xx);

		width=0.0;
		amp=0.0;
		if(lxx < -2.0)
		{
			width=0.700;
			amp=0.690;
		}
		else
		{
			if(lxx < -1.5)
			{
				width=0.550;
				amp=0.808;
			}
			else
			{
				width=0.353;
				amp=0.808;
			}
		}
		FFF=amp*exp(-0.5*(lxx-bg_centre)*(lxx-bg_centre)/(width*width))/(xx*log(10.0));
		FFF=FFF/34.734940;

		yy=(double) random()/(double) RAND_MAX;
		if(yy <= FFF)
		{
			xx2=100*xx;
		}
	}
	return xx2;
}
unsigned long long int rdtsc(void)
{
   unsigned long long int x;
   unsigned a, d;

   __asm__ volatile("rdtsc" : "=a" (a), "=d" (d));

   return ((unsigned long long)a) | (((unsigned long long)d) << 32);;
}
