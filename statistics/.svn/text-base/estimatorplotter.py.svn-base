#!/usr/bin/python
# This a python matplotlib script for generating plots of P0 Estimator accuracy

import sys
from optparse import OptionParser
import numpy as np
import pyfits
from matplotlib.ticker import *
from pylab import figure,show, setp
from matplotlib import rc

#These lists are used for storing data points from the statistics table
bins = []
I = []
P = []
P25 = []
P75 = []
N = []
mean_Poff = []
sig_Poff = []
model_Poff = []
sig_mode = []
P0_ML = []
P0_16 = []
P0_83 = []
P0_true= []
Percent = []
stackerr = []
modelerr = []
P2 = []
P3 = []
P4 = []
Funcvals = []
hline = []
#This is aconstant value used for computing the Pfunction estimator
A=0.5

if __name__ == "__main__":
	sigmaQU = 0.299108 #NVSS Simulation tile Noise
	#This function is a test estimator, it is not plotted
	Pfunction = lambda p, a: np.sqrt(p**2 - a*(sigmaQU**2))
	rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})
	rc('text', usetex=True)
	parser = OptionParser("riceplotter.py [options] infile")
	(options, args) = parser.parse_args()
	table = open(args[0]).readlines()
	linedict = {}
	for line in table:
		linedict[float(line.split()[14])] = line
	Ilist = linedict.keys()
	Ilist.sort()
	Ilist = filter(lambda x: x<10, Ilist)
	for Ival in Ilist:
		line = linedict[Ival]
		bins.append((float(line.split()[0]), float(line.split()[1])))
		I.append(float(line.split()[2]))
		P.append(float(line.split()[3]))
		P25.append(float(line.split()[4]))
		P75.append(float(line.split()[5]))
		N.append(float(line.split()[6]))
		mean_Poff.append(float(line.split()[7]))
		sig_Poff.append(float(line.split()[8]))
		model_Poff.append(float(line.split()[9]))
		sig_mode.append(float(line.split()[10]))
		P0_ML.append(float(line.split()[11]))
		P0_16.append(float(line.split()[12]))
		P0_83.append(float(line.split()[13]))
		P0_true.append(float(line.split()[14]))
		Percent.append(float(line.split()[11])/float(line.split()[2]))
		P2.append(float(line.split()[3])/float(line.split()[2]))
		P3.append(float(line.split()[12])/float(line.split()[2]))
		P4.append(float(line.split()[13])/float(line.split()[2]))
		stackerr.append(float(line.split()[8])/(float(line.split()[6])**2))
		modelerr.append(float(line.split()[10])/(float(line.split()[6])**2))
		hline.append(2.097906/100)
		Funcvals.append(Pfunction(float(line.split()[3]), A))
	fig = figure()
	#These Numpy arrays store the values from the Rice distribution for the 
	#Median and Wardle & Kronberg estimators in units of sigma
	P0_Rice = np.array([0, sigmaQU, 2*sigmaQU, 3*sigmaQU, 4*sigmaQU, 5*sigmaQU])
	Pmedian = np.array([1.1775, 1.4755, 2.2459, 3.1653, 4.1245, 5.0998])
	Pmedian = Pmedian * sigmaQU
	Pmax = np.array([1.0000, 1.3092, 2.2086, 3.1538, 4.1195, 5.0972])
	Pmax = Pmax * sigmaQU
	yprops = dict(rotation=90, horizontalalignment='right', size='small',
	verticalalignment='center')
	axprops = dict(yscale='log', xscale='log')
	ax1 = fig.add_axes([0.15, 0.15, 0.8, 0.8], **axprops)
	ax1.set_xlabel("P0")
	ax1.set_ylabel("P")
	ax1.plot(P0_true, P, 'ko-', label="Naive Estimator")
	ax1.plot(P0_Rice, Pmedian, 'g^-', label="Median Estimator")
	ax1.plot(P0_Rice, Pmax, 'g^--', label="Wardle \& Kronberg Estimator")
	ax1.plot(P0_true, P0_true, 'r', label="Ideal Estimator")
	ax1.plot(P0_true, P0_ML, 'ko--', label="Stil Hermitian Estimator")
	ax1.legend()
	#ax1.plot(P0_ML, P, 'ko--')
	#ax1.plot(Funcvals, P_median, 'ro-')
	#ax1.plot(P0_true, Funcvals, 'ro-')
	#ax1.plot(Funcvals, P, 'o')
	show()

