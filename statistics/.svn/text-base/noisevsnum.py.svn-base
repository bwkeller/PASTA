#!/usr/bin/python
#This is a matplotlib python script to generate a full statisitics plot using
#the statistics table.

import sys
from optparse import OptionParser
import numpy as np
import pyfits
from matplotlib.ticker import *
from pylab import figure,show, setp
from matplotlib import rc

#These lists are used for storing the statistics values read in from the files
N = []
noise = []


def compute_rms(n, bpercent=20):
		"""
		This is an private method used to compute the standard deviation of an outer "frame" 5 pixels thick.
		@type n:		ndarray
		@param n:		The array to compute the frame rms noise for.
		@type bpercent:		int
		@param bpercent:	The percentage of the total image size to make the frame for
		@return:		The value of the rms noise computed over the outer frame.
		"""
		thickness = 5#Default frame thickness
		if n.shape[0]*bpercent/100 > thickness:#Enlarge the thickness for bigger images
			thickness = n.shape[0]*bpercent/100
		bsize = (thickness*2*n.shape[0])+2*((n.shape[1]-2*thickness)*thickness)#calculate the size of the box
		mean = sum(n[:,:thickness].flatten()) + \
		sum(n[:thickness,thickness:(n.shape[1]-thickness)].flatten()) + \
		sum(n[(n.shape[0]-thickness):, 
		thickness:(n.shape[1]-thickness)].flatten()) + \
		sum(n[:,(n.shape[0]-thickness):].flatten())
		mean = mean / (bsize - 1)
		a = sum(np.power((n[:,:thickness]-mean), 2).flatten())#This computes the square sum of the left edge
		b = sum(np.power((n[:thickness, thickness:(n.shape[1]-thickness)]-mean), 2).flatten())# The upper edge
		c = sum(np.power((n[:,:thickness]-mean), 2).flatten())# The right edge
		d = sum(np.power((n[:,n.shape[0]-thickness:]-mean), 2).flatten())# The bottom edge
		return np.sqrt((a+b+c+d)/(bsize-1))
if __name__ == "__main__":
	rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})
	rc('text', usetex=True)
	parser = OptionParser("noisevsnum.py [options] infiles")
	parser.add_option("-t", action="store", type="string", dest="title")
	(options, args) = parser.parse_args()
	for arg in args:
		infile = pyfits.open(arg)
		inheader = infile[0].header
		N.append(inheader["STACKNUM"])
		noise.append(compute_rms(infile[0].data))
	fig = figure()
	expected = [0.00029/np.sqrt(i) for i in N]
	bestfit = np.polyfit(np.log10(N), np.log10(noise), 1)
	line = bestfit[0]*np.array(np.log10(N))+bestfit[1]
	yprops = dict(rotation=90, horizontalalignment='right', 
	verticalalignment='center')
	ax = fig.add_axes([0.15, 0.15, 0.8, 0.8])
	ax.plot(np.log10(N), np.log10(noise), 'o')
	ax.plot(np.log10(N), line, 'r--', label="Linear Fit")
	ax.plot(np.log10(N), np.log10(expected), 'k-', label="Expected Noise")
	ax.set_xlabel('log10 Number of Sources in Stack')
	ax.set_ylabel(r'log10 of Off-Source Background Noise', **yprops)
	ax.set_title(options.title)
	ax.legend()
	#ax.axis('tight')
	show()

