#!/usr/bin/python
#This is a matplotlib python script to generate a full statisitics plot using
#the statistics table.

import sys
from optparse import OptionParser
import numpy as np
import pyfits
from matplotlib.ticker import *
from pylab import figure,show, setp
from matplotlib import rc

#These lists are used for storing the statistics values read in from the table
bins = []
I = []
P = []
P25 = []
P75 = []
N = []
mean_Poff = []
sig_Poff = []
model_Poff = []
sig_mode = []
P0_ML = []
P0_16 = []
P0_83 = []
P_median = []
Percent = []
stackerr = []
modelerr = []
P2 = []
P3 = []
P4 = []
hline = []


if __name__ == "__main__":
	rc('font',**{'family':'sans-serif','sans-serif':['Helvetica'], 'size':14})
	rc('text', usetex=True)
	parser = OptionParser("statplotter.py [options] infile")
	parser.add_option("-l", action="store_true", dest="hline", 
	help="include a True P0 line")
	(options, args) = parser.parse_args()
	table = open(args[0]).readlines()
	linedict = {}
	for line in table:
		linedict[float(line.split()[2])] = line
	Ilist = linedict.keys()
	Ilist.sort()
	#This reads in the statistics values
	for Ival in Ilist:
		line = linedict[Ival]
		bins.append((float(line.split()[0]), float(line.split()[1])))
		I.append(float(line.split()[2]))
		P.append(float(line.split()[3]))
		P25.append(float(line.split()[4]))
		P75.append(float(line.split()[5]))
		N.append(float(line.split()[6]))
		mean_Poff.append(float(line.split()[7]))
		sig_Poff.append(float(line.split()[8]))
		model_Poff.append(float(line.split()[9]))
		sig_mode.append(float(line.split()[10]))
		P0_ML.append(float(line.split()[11]))
		P0_16.append(float(line.split()[12]))
		P0_83.append(float(line.split()[13]))
		#P_median.append(float(line.split()[14]))
		#This percent is based on the most likely P0
		Percent.append(100*float(line.split()[11])/float(line.split()[2]))
		#This percent is based on the observed P
		P2.append(100*float(line.split()[3])/float(line.split()[2]))
		#This percent is based on the 16.5th percentile ML P0
		P3.append(Percent[-1]-100*float(line.split()[12])/float(line.split()[2]))
		#This percent is based on the 83.5th percentile ML P0
		P4.append(100*float(line.split()[13])/float(line.split()[2])-Percent[-1])
		stackerr.append(float(line.split()[8])/(float(line.split()[6])**2))
		modelerr.append(float(line.split()[10])/(float(line.split()[6])**2))
		#This line is a constant percentage polarization
		hline.append(2.097906)
		I[-1] = (float(line.split()[0]) + float(line.split()[1]))/2
	(xmin, xmax) = (bins[0][0], bins[-1][1])
	fig = figure()
	yprops = dict(rotation=90, horizontalalignment='right', size='small',
	verticalalignment='center', x=-0.01)
	#axprops = dict(yticks=[])
	axprops = dict(yscale='log', xscale='log', autoscalex_on=False)
	#ax1 plots the Number of sources vs I
	ax1 = fig.add_axes([0.15, 0.64, 0.8, 0.27], **axprops)
	ax1.plot(I, N, 'ko-')
	ax1.xaxis.set_visible(False)
	ax1.set_autoscale_on(False)
	ax1.set_ylabel(r'$N_{stack}$', **yprops)
	ax1.axis('tight')
	#NVSS Range
	#ax1.set_xlim([1.5, 1200])
	#Simulation range
	ax1.set_xlim([0.7, 3700])
	#NVSS Range
	ax1.set_ylim([20, 40000])
	#Simulation range
	ax1.set_ylim([1, 40000])
	for line in ax1.get_yticklines():
		line.set_markersize(8)
	for line in ax1.yaxis.get_minorticklines():
		line.set_markersize(5)
	axprops['yscale']='log'
	#ax2 plots stack P, simulation true P0, most likely P0, 16.5th and 83.5th 
	#percentile vs I
	ax2 = fig.add_axes([0.15, 0.37, 0.8, 0.27], **axprops)
	ax2.plot(I, P, color='0.8', marker='o')
	ax2.plot(I, P0_ML, 'ko-', I, P0_16, 'k--', I, P0_83, 'k--')
	ax2.xaxis.set_visible(False)
	ax2.set_ylabel(r'$P_0(mJy/beam)$', **yprops)
	ax2.axis('tight')
	#NVSS Range
	#ax2.set_xlim([1.5, 1200])
	#Simulation range
	ax2.set_xlim([0.7, 3700])
	#NVSS Range
	#ax2.set_ylim([0.02, 25])
	#Simulation range
	ax2.set_ylim([0.009, 255])
	for line in ax2.get_yticklines():
		line.set_markersize(8)
	for line in ax2.yaxis.get_minorticklines():
		line.set_markersize(5)
	axprops['yscale']='linear'
	#ax3 plots the Percent polarization based on observed P, P0_ML, P0_16,
	#P0_83, and true simulation P0 vs I
	ax3 = fig.add_axes([0.15, 0.1, 0.8, 0.27], **axprops)
	ax3.errorbar(I, Percent, [P3, P4])
	if options.hline:
		ax3.plot(I, P2, 'g-', I, hline, 'r--')
	else:
		ax3.plot(I, P2, 'g-')
	ax3.axis('tight')
	ax3.set_ylabel(r'$\Pi_0(\%)$', **yprops)
	ax3.set_xlabel(r'Stokes I (mJy/beam)')
	ax3.set_autoscale_on(False)
	ax3.set_ylim([0.0, 6])
	#NVSS Range
	#ax3.set_xlim([1.5, 1200])
	#Simulation range
	ax3.set_xlim([0.7, 3700])
	for line in ax3.get_yticklines():
		line.set_markersize(8)
	for line in ax3.yaxis.get_minorticklines():
		line.set_markersize(5)
	fig.savefig('3pane.eps')
	show()

